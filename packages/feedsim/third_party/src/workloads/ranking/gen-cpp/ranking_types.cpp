/**
 * Autogenerated by Thrift Compiler (0.13.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "ranking_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace ranking {

int _kRankingStoryTypeValues[] = {
  RankingStoryType::STORY_TYPE_A,
  RankingStoryType::STORY_TYPE_B,
  RankingStoryType::STORY_TYPE_C,
  RankingStoryType::STORY_TYPE_D,
  RankingStoryType::STORY_TYPE_E,
  RankingStoryType::STORY_TYPE_F,
  RankingStoryType::STORY_TYPE_G,
  RankingStoryType::STORY_TYPE_H,
  RankingStoryType::STORY_TYPE_I,
  RankingStoryType::STORY_TYPE_J,
  RankingStoryType::STORY_TYPE_K,
  RankingStoryType::STORY_TYPE_L,
  RankingStoryType::STORY_TYPE_M,
  RankingStoryType::STORY_TYPE_N,
  RankingStoryType::STORY_TYPE_O,
  RankingStoryType::STORY_TYPE_P,
  RankingStoryType::STORY_TYPE_Q,
  RankingStoryType::STORY_TYPE_R,
  RankingStoryType::STORY_TYPE_S,
  RankingStoryType::STORY_TYPE_T,
  RankingStoryType::STORY_TYPE_U,
  RankingStoryType::STORY_TYPE_V,
  RankingStoryType::STORY_TYPE_W,
  RankingStoryType::STORY_TYPE_X,
  RankingStoryType::STORY_TYPE_Y,
  RankingStoryType::STORY_TYPE_Z
};
const char* _kRankingStoryTypeNames[] = {
  "STORY_TYPE_A",
  "STORY_TYPE_B",
  "STORY_TYPE_C",
  "STORY_TYPE_D",
  "STORY_TYPE_E",
  "STORY_TYPE_F",
  "STORY_TYPE_G",
  "STORY_TYPE_H",
  "STORY_TYPE_I",
  "STORY_TYPE_J",
  "STORY_TYPE_K",
  "STORY_TYPE_L",
  "STORY_TYPE_M",
  "STORY_TYPE_N",
  "STORY_TYPE_O",
  "STORY_TYPE_P",
  "STORY_TYPE_Q",
  "STORY_TYPE_R",
  "STORY_TYPE_S",
  "STORY_TYPE_T",
  "STORY_TYPE_U",
  "STORY_TYPE_V",
  "STORY_TYPE_W",
  "STORY_TYPE_X",
  "STORY_TYPE_Y",
  "STORY_TYPE_Z"
};
const std::map<int, const char*> _RankingStoryType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(26, _kRankingStoryTypeValues, _kRankingStoryTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const RankingStoryType::type& val) {
  std::map<int, const char*>::const_iterator it = _RankingStoryType_VALUES_TO_NAMES.find(val);
  if (it != _RankingStoryType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const RankingStoryType::type& val) {
  std::map<int, const char*>::const_iterator it = _RankingStoryType_VALUES_TO_NAMES.find(val);
  if (it != _RankingStoryType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kRankingObjectTypeValues[] = {
  RankingObjectType::OBJ_TYPE_A,
  RankingObjectType::OBJ_TYPE_B,
  RankingObjectType::OBJ_TYPE_C,
  RankingObjectType::OBJ_TYPE_D,
  RankingObjectType::OBJ_TYPE_E,
  RankingObjectType::OBJ_TYPE_F,
  RankingObjectType::OBJ_TYPE_G,
  RankingObjectType::OBJ_TYPE_H,
  RankingObjectType::OBJ_TYPE_I,
  RankingObjectType::OBJ_TYPE_J,
  RankingObjectType::OBJ_TYPE_K,
  RankingObjectType::OBJ_TYPE_L,
  RankingObjectType::OBJ_TYPE_M,
  RankingObjectType::OBJ_TYPE_N,
  RankingObjectType::OBJ_TYPE_O,
  RankingObjectType::OBJ_TYPE_P,
  RankingObjectType::OBJ_TYPE_Q,
  RankingObjectType::OBJ_TYPE_R,
  RankingObjectType::OBJ_TYPE_S,
  RankingObjectType::OBJ_TYPE_T,
  RankingObjectType::OBJ_TYPE_U,
  RankingObjectType::OBJ_TYPE_V,
  RankingObjectType::OBJ_TYPE_W,
  RankingObjectType::OBJ_TYPE_X,
  RankingObjectType::OBJ_TYPE_Y,
  RankingObjectType::OBJ_TYPE_Z
};
const char* _kRankingObjectTypeNames[] = {
  "OBJ_TYPE_A",
  "OBJ_TYPE_B",
  "OBJ_TYPE_C",
  "OBJ_TYPE_D",
  "OBJ_TYPE_E",
  "OBJ_TYPE_F",
  "OBJ_TYPE_G",
  "OBJ_TYPE_H",
  "OBJ_TYPE_I",
  "OBJ_TYPE_J",
  "OBJ_TYPE_K",
  "OBJ_TYPE_L",
  "OBJ_TYPE_M",
  "OBJ_TYPE_N",
  "OBJ_TYPE_O",
  "OBJ_TYPE_P",
  "OBJ_TYPE_Q",
  "OBJ_TYPE_R",
  "OBJ_TYPE_S",
  "OBJ_TYPE_T",
  "OBJ_TYPE_U",
  "OBJ_TYPE_V",
  "OBJ_TYPE_W",
  "OBJ_TYPE_X",
  "OBJ_TYPE_Y",
  "OBJ_TYPE_Z"
};
const std::map<int, const char*> _RankingObjectType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(26, _kRankingObjectTypeValues, _kRankingObjectTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const RankingObjectType::type& val) {
  std::map<int, const char*>::const_iterator it = _RankingObjectType_VALUES_TO_NAMES.find(val);
  if (it != _RankingObjectType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const RankingObjectType::type& val) {
  std::map<int, const char*>::const_iterator it = _RankingObjectType_VALUES_TO_NAMES.find(val);
  if (it != _RankingObjectType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}


Payload::~Payload() noexcept {
}


void Payload::__set_message(const std::string& val) {
  this->message = val;
}
std::ostream& operator<<(std::ostream& out, const Payload& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Payload::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Payload::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Payload");

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Payload &a, Payload &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

Payload::Payload(const Payload& other0) {
  message = other0.message;
  __isset = other0.__isset;
}
Payload::Payload( Payload&& other1) {
  message = std::move(other1.message);
  __isset = std::move(other1.__isset);
}
Payload& Payload::operator=(const Payload& other2) {
  message = other2.message;
  __isset = other2.__isset;
  return *this;
}
Payload& Payload::operator=(Payload&& other3) {
  message = std::move(other3.message);
  __isset = std::move(other3.__isset);
  return *this;
}
void Payload::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Payload(";
  out << "message=" << to_string(message);
  out << ")";
}


Action::~Action() noexcept {
}


void Action::__set_type(const int16_t val) {
  this->type = val;
}

void Action::__set_timeUsec(const int64_t val) {
  this->timeUsec = val;
}

void Action::__set_timeMsec(const int32_t val) {
  this->timeMsec = val;
}

void Action::__set_actorID(const int64_t val) {
  this->actorID = val;
}
std::ostream& operator<<(std::ostream& out, const Action& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Action::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->type);
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timeUsec);
          this->__isset.timeUsec = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->timeMsec);
          this->__isset.timeMsec = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->actorID);
          this->__isset.actorID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Action::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Action");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("timeUsec", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->timeUsec);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("timeMsec", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->timeMsec);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("actorID", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->actorID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Action &a, Action &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.timeUsec, b.timeUsec);
  swap(a.timeMsec, b.timeMsec);
  swap(a.actorID, b.actorID);
  swap(a.__isset, b.__isset);
}

Action::Action(const Action& other4) {
  type = other4.type;
  timeUsec = other4.timeUsec;
  timeMsec = other4.timeMsec;
  actorID = other4.actorID;
  __isset = other4.__isset;
}
Action::Action( Action&& other5) {
  type = std::move(other5.type);
  timeUsec = std::move(other5.timeUsec);
  timeMsec = std::move(other5.timeMsec);
  actorID = std::move(other5.actorID);
  __isset = std::move(other5.__isset);
}
Action& Action::operator=(const Action& other6) {
  type = other6.type;
  timeUsec = other6.timeUsec;
  timeMsec = other6.timeMsec;
  actorID = other6.actorID;
  __isset = other6.__isset;
  return *this;
}
Action& Action::operator=(Action&& other7) {
  type = std::move(other7.type);
  timeUsec = std::move(other7.timeUsec);
  timeMsec = std::move(other7.timeMsec);
  actorID = std::move(other7.actorID);
  __isset = std::move(other7.__isset);
  return *this;
}
void Action::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Action(";
  out << "type=" << to_string(type);
  out << ", " << "timeUsec=" << to_string(timeUsec);
  out << ", " << "timeMsec=" << to_string(timeMsec);
  out << ", " << "actorID=" << to_string(actorID);
  out << ")";
}


RankingObject::~RankingObject() noexcept {
}


void RankingObject::__set_objectID(const int64_t val) {
  this->objectID = val;
}

void RankingObject::__set_objectType(const RankingObjectType::type val) {
  this->objectType = val;
}

void RankingObject::__set_actorID(const int64_t val) {
  this->actorID = val;
}

void RankingObject::__set_createTime(const int64_t val) {
  this->createTime = val;
}

void RankingObject::__set_payloadIntMap(const RankingPayloadIntMap& val) {
  this->payloadIntMap = val;
}

void RankingObject::__set_payloadStrMap(const RankingPayloadStringMap& val) {
  this->payloadStrMap = val;
}

void RankingObject::__set_payloadVecMap(const RankingPayloadVecMap& val) {
  this->payloadVecMap = val;
}

void RankingObject::__set_actions(const std::vector<Action> & val) {
  this->actions = val;
}

void RankingObject::__set_weight(const double val) {
  this->weight = val;
}
std::ostream& operator<<(std::ostream& out, const RankingObject& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t RankingObject::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->objectID);
          this->__isset.objectID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast8;
          xfer += iprot->readI32(ecast8);
          this->objectType = (RankingObjectType::type)ecast8;
          this->__isset.objectType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->actorID);
          this->__isset.actorID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->createTime);
          this->__isset.createTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->payloadIntMap.clear();
            uint32_t _size9;
            ::apache::thrift::protocol::TType _ktype10;
            ::apache::thrift::protocol::TType _vtype11;
            xfer += iprot->readMapBegin(_ktype10, _vtype11, _size9);
            uint32_t _i13;
            for (_i13 = 0; _i13 < _size9; ++_i13)
            {
              int16_t _key14;
              xfer += iprot->readI16(_key14);
              int64_t& _val15 = this->payloadIntMap[_key14];
              xfer += iprot->readI64(_val15);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.payloadIntMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->payloadStrMap.clear();
            uint32_t _size16;
            ::apache::thrift::protocol::TType _ktype17;
            ::apache::thrift::protocol::TType _vtype18;
            xfer += iprot->readMapBegin(_ktype17, _vtype18, _size16);
            uint32_t _i20;
            for (_i20 = 0; _i20 < _size16; ++_i20)
            {
              int16_t _key21;
              xfer += iprot->readI16(_key21);
              std::string& _val22 = this->payloadStrMap[_key21];
              xfer += iprot->readString(_val22);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.payloadStrMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->payloadVecMap.clear();
            uint32_t _size23;
            ::apache::thrift::protocol::TType _ktype24;
            ::apache::thrift::protocol::TType _vtype25;
            xfer += iprot->readMapBegin(_ktype24, _vtype25, _size23);
            uint32_t _i27;
            for (_i27 = 0; _i27 < _size23; ++_i27)
            {
              int16_t _key28;
              xfer += iprot->readI16(_key28);
              SmallListI64& _val29 = this->payloadVecMap[_key28];
              {
                _val29.clear();
                uint32_t _size30;
                ::apache::thrift::protocol::TType _etype33;
                xfer += iprot->readListBegin(_etype33, _size30);
                _val29.resize(_size30);
                uint32_t _i34;
                for (_i34 = 0; _i34 < _size30; ++_i34)
                {
                  xfer += iprot->readI64(_val29[_i34]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.payloadVecMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->actions.clear();
            uint32_t _size35;
            ::apache::thrift::protocol::TType _etype38;
            xfer += iprot->readListBegin(_etype38, _size35);
            this->actions.resize(_size35);
            uint32_t _i39;
            for (_i39 = 0; _i39 < _size35; ++_i39)
            {
              xfer += this->actions[_i39].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.actions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->weight);
          this->__isset.weight = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t RankingObject::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("RankingObject");

  xfer += oprot->writeFieldBegin("objectID", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->objectID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("objectType", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->objectType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("actorID", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->actorID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("createTime", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->createTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("payloadIntMap", ::apache::thrift::protocol::T_MAP, 5);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I16, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->payloadIntMap.size()));
    std::map<int16_t, int64_t> ::const_iterator _iter40;
    for (_iter40 = this->payloadIntMap.begin(); _iter40 != this->payloadIntMap.end(); ++_iter40)
    {
      xfer += oprot->writeI16(_iter40->first);
      xfer += oprot->writeI64(_iter40->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("payloadStrMap", ::apache::thrift::protocol::T_MAP, 6);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I16, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->payloadStrMap.size()));
    std::map<int16_t, std::string> ::const_iterator _iter41;
    for (_iter41 = this->payloadStrMap.begin(); _iter41 != this->payloadStrMap.end(); ++_iter41)
    {
      xfer += oprot->writeI16(_iter41->first);
      xfer += oprot->writeString(_iter41->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("payloadVecMap", ::apache::thrift::protocol::T_MAP, 7);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I16, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->payloadVecMap.size()));
    std::map<int16_t, SmallListI64> ::const_iterator _iter42;
    for (_iter42 = this->payloadVecMap.begin(); _iter42 != this->payloadVecMap.end(); ++_iter42)
    {
      xfer += oprot->writeI16(_iter42->first);
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(_iter42->second.size()));
        std::vector<int64_t> ::const_iterator _iter43;
        for (_iter43 = _iter42->second.begin(); _iter43 != _iter42->second.end(); ++_iter43)
        {
          xfer += oprot->writeI64((*_iter43));
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("actions", ::apache::thrift::protocol::T_LIST, 8);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->actions.size()));
    std::vector<Action> ::const_iterator _iter44;
    for (_iter44 = this->actions.begin(); _iter44 != this->actions.end(); ++_iter44)
    {
      xfer += (*_iter44).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("weight", ::apache::thrift::protocol::T_DOUBLE, 9);
  xfer += oprot->writeDouble(this->weight);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RankingObject &a, RankingObject &b) {
  using ::std::swap;
  swap(a.objectID, b.objectID);
  swap(a.objectType, b.objectType);
  swap(a.actorID, b.actorID);
  swap(a.createTime, b.createTime);
  swap(a.payloadIntMap, b.payloadIntMap);
  swap(a.payloadStrMap, b.payloadStrMap);
  swap(a.payloadVecMap, b.payloadVecMap);
  swap(a.actions, b.actions);
  swap(a.weight, b.weight);
  swap(a.__isset, b.__isset);
}

RankingObject::RankingObject(const RankingObject& other45) {
  objectID = other45.objectID;
  objectType = other45.objectType;
  actorID = other45.actorID;
  createTime = other45.createTime;
  payloadIntMap = other45.payloadIntMap;
  payloadStrMap = other45.payloadStrMap;
  payloadVecMap = other45.payloadVecMap;
  actions = other45.actions;
  weight = other45.weight;
  __isset = other45.__isset;
}
RankingObject::RankingObject( RankingObject&& other46) {
  objectID = std::move(other46.objectID);
  objectType = std::move(other46.objectType);
  actorID = std::move(other46.actorID);
  createTime = std::move(other46.createTime);
  payloadIntMap = std::move(other46.payloadIntMap);
  payloadStrMap = std::move(other46.payloadStrMap);
  payloadVecMap = std::move(other46.payloadVecMap);
  actions = std::move(other46.actions);
  weight = std::move(other46.weight);
  __isset = std::move(other46.__isset);
}
RankingObject& RankingObject::operator=(const RankingObject& other47) {
  objectID = other47.objectID;
  objectType = other47.objectType;
  actorID = other47.actorID;
  createTime = other47.createTime;
  payloadIntMap = other47.payloadIntMap;
  payloadStrMap = other47.payloadStrMap;
  payloadVecMap = other47.payloadVecMap;
  actions = other47.actions;
  weight = other47.weight;
  __isset = other47.__isset;
  return *this;
}
RankingObject& RankingObject::operator=(RankingObject&& other48) {
  objectID = std::move(other48.objectID);
  objectType = std::move(other48.objectType);
  actorID = std::move(other48.actorID);
  createTime = std::move(other48.createTime);
  payloadIntMap = std::move(other48.payloadIntMap);
  payloadStrMap = std::move(other48.payloadStrMap);
  payloadVecMap = std::move(other48.payloadVecMap);
  actions = std::move(other48.actions);
  weight = std::move(other48.weight);
  __isset = std::move(other48.__isset);
  return *this;
}
void RankingObject::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "RankingObject(";
  out << "objectID=" << to_string(objectID);
  out << ", " << "objectType=" << to_string(objectType);
  out << ", " << "actorID=" << to_string(actorID);
  out << ", " << "createTime=" << to_string(createTime);
  out << ", " << "payloadIntMap=" << to_string(payloadIntMap);
  out << ", " << "payloadStrMap=" << to_string(payloadStrMap);
  out << ", " << "payloadVecMap=" << to_string(payloadVecMap);
  out << ", " << "actions=" << to_string(actions);
  out << ", " << "weight=" << to_string(weight);
  out << ")";
}


RankingStory::~RankingStory() noexcept {
}


void RankingStory::__set_storyID(const int64_t val) {
  this->storyID = val;
}

void RankingStory::__set_objects(const std::vector<RankingObject> & val) {
  this->objects = val;
}

void RankingStory::__set_weight(const double val) {
  this->weight = val;
}

void RankingStory::__set_storyType(const RankingStoryType::type val) {
  this->storyType = val;
}
std::ostream& operator<<(std::ostream& out, const RankingStory& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t RankingStory::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->storyID);
          this->__isset.storyID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->objects.clear();
            uint32_t _size49;
            ::apache::thrift::protocol::TType _etype52;
            xfer += iprot->readListBegin(_etype52, _size49);
            this->objects.resize(_size49);
            uint32_t _i53;
            for (_i53 = 0; _i53 < _size49; ++_i53)
            {
              xfer += this->objects[_i53].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.objects = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->weight);
          this->__isset.weight = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast54;
          xfer += iprot->readI32(ecast54);
          this->storyType = (RankingStoryType::type)ecast54;
          this->__isset.storyType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t RankingStory::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("RankingStory");

  xfer += oprot->writeFieldBegin("storyID", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->storyID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("objects", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->objects.size()));
    std::vector<RankingObject> ::const_iterator _iter55;
    for (_iter55 = this->objects.begin(); _iter55 != this->objects.end(); ++_iter55)
    {
      xfer += (*_iter55).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("weight", ::apache::thrift::protocol::T_DOUBLE, 3);
  xfer += oprot->writeDouble(this->weight);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("storyType", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((int32_t)this->storyType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RankingStory &a, RankingStory &b) {
  using ::std::swap;
  swap(a.storyID, b.storyID);
  swap(a.objects, b.objects);
  swap(a.weight, b.weight);
  swap(a.storyType, b.storyType);
  swap(a.__isset, b.__isset);
}

RankingStory::RankingStory(const RankingStory& other56) {
  storyID = other56.storyID;
  objects = other56.objects;
  weight = other56.weight;
  storyType = other56.storyType;
  __isset = other56.__isset;
}
RankingStory::RankingStory( RankingStory&& other57) {
  storyID = std::move(other57.storyID);
  objects = std::move(other57.objects);
  weight = std::move(other57.weight);
  storyType = std::move(other57.storyType);
  __isset = std::move(other57.__isset);
}
RankingStory& RankingStory::operator=(const RankingStory& other58) {
  storyID = other58.storyID;
  objects = other58.objects;
  weight = other58.weight;
  storyType = other58.storyType;
  __isset = other58.__isset;
  return *this;
}
RankingStory& RankingStory::operator=(RankingStory&& other59) {
  storyID = std::move(other59.storyID);
  objects = std::move(other59.objects);
  weight = std::move(other59.weight);
  storyType = std::move(other59.storyType);
  __isset = std::move(other59.__isset);
  return *this;
}
void RankingStory::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "RankingStory(";
  out << "storyID=" << to_string(storyID);
  out << ", " << "objects=" << to_string(objects);
  out << ", " << "weight=" << to_string(weight);
  out << ", " << "storyType=" << to_string(storyType);
  out << ")";
}


RankingResponse::~RankingResponse() noexcept {
}


void RankingResponse::__set_queryID(const int64_t val) {
  this->queryID = val;
}

void RankingResponse::__set_rankingStories(const std::vector<RankingStory> & val) {
  this->rankingStories = val;
}

void RankingResponse::__set_objectCounts(const std::vector<int32_t> & val) {
  this->objectCounts = val;
}

void RankingResponse::__set_metadata(const std::string& val) {
  this->metadata = val;
}
std::ostream& operator<<(std::ostream& out, const RankingResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t RankingResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->queryID);
          this->__isset.queryID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->rankingStories.clear();
            uint32_t _size60;
            ::apache::thrift::protocol::TType _etype63;
            xfer += iprot->readListBegin(_etype63, _size60);
            this->rankingStories.resize(_size60);
            uint32_t _i64;
            for (_i64 = 0; _i64 < _size60; ++_i64)
            {
              xfer += this->rankingStories[_i64].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.rankingStories = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->objectCounts.clear();
            uint32_t _size65;
            ::apache::thrift::protocol::TType _etype68;
            xfer += iprot->readListBegin(_etype68, _size65);
            this->objectCounts.resize(_size65);
            uint32_t _i69;
            for (_i69 = 0; _i69 < _size65; ++_i69)
            {
              xfer += iprot->readI32(this->objectCounts[_i69]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.objectCounts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->metadata);
          this->__isset.metadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t RankingResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("RankingResponse");

  xfer += oprot->writeFieldBegin("queryID", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->queryID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rankingStories", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->rankingStories.size()));
    std::vector<RankingStory> ::const_iterator _iter70;
    for (_iter70 = this->rankingStories.begin(); _iter70 != this->rankingStories.end(); ++_iter70)
    {
      xfer += (*_iter70).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("objectCounts", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->objectCounts.size()));
    std::vector<int32_t> ::const_iterator _iter71;
    for (_iter71 = this->objectCounts.begin(); _iter71 != this->objectCounts.end(); ++_iter71)
    {
      xfer += oprot->writeI32((*_iter71));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("metadata", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->metadata);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RankingResponse &a, RankingResponse &b) {
  using ::std::swap;
  swap(a.queryID, b.queryID);
  swap(a.rankingStories, b.rankingStories);
  swap(a.objectCounts, b.objectCounts);
  swap(a.metadata, b.metadata);
  swap(a.__isset, b.__isset);
}

RankingResponse::RankingResponse(const RankingResponse& other72) {
  queryID = other72.queryID;
  rankingStories = other72.rankingStories;
  objectCounts = other72.objectCounts;
  metadata = other72.metadata;
  __isset = other72.__isset;
}
RankingResponse::RankingResponse( RankingResponse&& other73) {
  queryID = std::move(other73.queryID);
  rankingStories = std::move(other73.rankingStories);
  objectCounts = std::move(other73.objectCounts);
  metadata = std::move(other73.metadata);
  __isset = std::move(other73.__isset);
}
RankingResponse& RankingResponse::operator=(const RankingResponse& other74) {
  queryID = other74.queryID;
  rankingStories = other74.rankingStories;
  objectCounts = other74.objectCounts;
  metadata = other74.metadata;
  __isset = other74.__isset;
  return *this;
}
RankingResponse& RankingResponse::operator=(RankingResponse&& other75) {
  queryID = std::move(other75.queryID);
  rankingStories = std::move(other75.rankingStories);
  objectCounts = std::move(other75.objectCounts);
  metadata = std::move(other75.metadata);
  __isset = std::move(other75.__isset);
  return *this;
}
void RankingResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "RankingResponse(";
  out << "queryID=" << to_string(queryID);
  out << ", " << "rankingStories=" << to_string(rankingStories);
  out << ", " << "objectCounts=" << to_string(objectCounts);
  out << ", " << "metadata=" << to_string(metadata);
  out << ")";
}

} // namespace
