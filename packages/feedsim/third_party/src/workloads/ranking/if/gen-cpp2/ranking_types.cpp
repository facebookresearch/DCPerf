/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "ranking/if/gen-cpp2/ranking_types.h"
#include "ranking/if/gen-cpp2/ranking_types.tcc"

#include <thrift/lib/cpp2/gen/module_types_cpp.h>

#include "ranking/if/gen-cpp2/ranking_data.h"


namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::ranking::RankingStoryType>::size;
folly::Range<::ranking::RankingStoryType const*> const TEnumTraits<::ranking::RankingStoryType>::values = folly::range(::ranking::_RankingStoryTypeEnumDataStorage::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::ranking::RankingStoryType>::names = folly::range(::ranking::_RankingStoryTypeEnumDataStorage::names);

char const* TEnumTraits<::ranking::RankingStoryType>::findName(type value) {
  using factory = ::ranking::_RankingStoryType_EnumMapFactory;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::ranking::RankingStoryType>::findValue(char const* name, type* out) {
  using factory = ::ranking::_RankingStoryType_EnumMapFactory;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}

}} // apache::thrift

namespace ranking {

const _RankingStoryType_EnumMapFactory::ValuesToNamesMapType _RankingStoryType_VALUES_TO_NAMES = _RankingStoryType_EnumMapFactory::makeValuesToNamesMap();
const _RankingStoryType_EnumMapFactory::NamesToValuesMapType _RankingStoryType_NAMES_TO_VALUES = _RankingStoryType_EnumMapFactory::makeNamesToValuesMap();

} // ranking

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::ranking::RankingObjectType>::size;
folly::Range<::ranking::RankingObjectType const*> const TEnumTraits<::ranking::RankingObjectType>::values = folly::range(::ranking::_RankingObjectTypeEnumDataStorage::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::ranking::RankingObjectType>::names = folly::range(::ranking::_RankingObjectTypeEnumDataStorage::names);

char const* TEnumTraits<::ranking::RankingObjectType>::findName(type value) {
  using factory = ::ranking::_RankingObjectType_EnumMapFactory;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::ranking::RankingObjectType>::findValue(char const* name, type* out) {
  using factory = ::ranking::_RankingObjectType_EnumMapFactory;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}

}} // apache::thrift

namespace ranking {

const _RankingObjectType_EnumMapFactory::ValuesToNamesMapType _RankingObjectType_VALUES_TO_NAMES = _RankingObjectType_EnumMapFactory::makeValuesToNamesMap();
const _RankingObjectType_EnumMapFactory::NamesToValuesMapType _RankingObjectType_NAMES_TO_VALUES = _RankingObjectType_EnumMapFactory::makeNamesToValuesMap();

} // ranking

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::ranking::Payload>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) {
  if (false) {}
  else if (_fname == "message") {
    fid = 1;
    _ftype = apache::thrift::protocol::T_STRING;
  }
}
void TccStructTraits<::ranking::Action>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) {
  if (false) {}
  else if (_fname == "type") {
    fid = 1;
    _ftype = apache::thrift::protocol::T_I16;
  }
  else if (_fname == "timeUsec") {
    fid = 2;
    _ftype = apache::thrift::protocol::T_I64;
  }
  else if (_fname == "timeMsec") {
    fid = 3;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "actorID") {
    fid = 4;
    _ftype = apache::thrift::protocol::T_I64;
  }
}
void TccStructTraits<::ranking::RankingObject>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) {
  if (false) {}
  else if (_fname == "objectID") {
    fid = 1;
    _ftype = apache::thrift::protocol::T_I64;
  }
  else if (_fname == "objectType") {
    fid = 2;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "actorID") {
    fid = 3;
    _ftype = apache::thrift::protocol::T_I64;
  }
  else if (_fname == "createTime") {
    fid = 4;
    _ftype = apache::thrift::protocol::T_I64;
  }
  else if (_fname == "payloadIntMap") {
    fid = 5;
    _ftype = apache::thrift::protocol::T_MAP;
  }
  else if (_fname == "payloadStrMap") {
    fid = 6;
    _ftype = apache::thrift::protocol::T_MAP;
  }
  else if (_fname == "payloadVecMap") {
    fid = 7;
    _ftype = apache::thrift::protocol::T_MAP;
  }
  else if (_fname == "actions") {
    fid = 8;
    _ftype = apache::thrift::protocol::T_LIST;
  }
  else if (_fname == "weight") {
    fid = 9;
    _ftype = apache::thrift::protocol::T_DOUBLE;
  }
}
void TccStructTraits<::ranking::RankingStory>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) {
  if (false) {}
  else if (_fname == "storyID") {
    fid = 1;
    _ftype = apache::thrift::protocol::T_I64;
  }
  else if (_fname == "objects") {
    fid = 2;
    _ftype = apache::thrift::protocol::T_LIST;
  }
  else if (_fname == "weight") {
    fid = 3;
    _ftype = apache::thrift::protocol::T_DOUBLE;
  }
  else if (_fname == "storyType") {
    fid = 4;
    _ftype = apache::thrift::protocol::T_I32;
  }
}
void TccStructTraits<::ranking::RankingResponse>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) {
  if (false) {}
  else if (_fname == "queryID") {
    fid = 1;
    _ftype = apache::thrift::protocol::T_I64;
  }
  else if (_fname == "rankingStories") {
    fid = 2;
    _ftype = apache::thrift::protocol::T_LIST;
  }
  else if (_fname == "objectCounts") {
    fid = 3;
    _ftype = apache::thrift::protocol::T_LIST;
  }
  else if (_fname == "metadata") {
    fid = 4;
    _ftype = apache::thrift::protocol::T_STRING;
  }
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace ranking {

Payload::Payload(apache::thrift::FragileConstructor, ::std::string message__arg) :
    message(std::move(message__arg)) {
  __isset.message = true;
}

void Payload::__clear() {
  // clear all fields
  message = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  __isset = {};
}

bool Payload::operator==(const Payload& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.message == rhs.message)) {
    return false;
  }
  return true;
}

bool Payload::operator<(const Payload& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.message == rhs.message)) {
    return lhs.message < rhs.message;
  }
  return false;
}


void swap(Payload& a, Payload& b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

template void Payload::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t Payload::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t Payload::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t Payload::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void Payload::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t Payload::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t Payload::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t Payload::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

} // ranking
namespace ranking {

Action::Action(apache::thrift::FragileConstructor, int16_t type__arg, int64_t timeUsec__arg, int32_t timeMsec__arg, int64_t actorID__arg) :
    type(std::move(type__arg)),
    timeUsec(std::move(timeUsec__arg)),
    timeMsec(std::move(timeMsec__arg)),
    actorID(std::move(actorID__arg)) {
  __isset.type = true;
  __isset.timeUsec = true;
  __isset.timeMsec = true;
  __isset.actorID = true;
}

void Action::__clear() {
  // clear all fields
  type = 0;
  timeUsec = 0;
  timeMsec = 0;
  actorID = 0;
  __isset = {};
}

bool Action::operator==(const Action& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.type == rhs.type)) {
    return false;
  }
  if (!(lhs.timeUsec == rhs.timeUsec)) {
    return false;
  }
  if (!(lhs.timeMsec == rhs.timeMsec)) {
    return false;
  }
  if (!(lhs.actorID == rhs.actorID)) {
    return false;
  }
  return true;
}

bool Action::operator<(const Action& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.type == rhs.type)) {
    return lhs.type < rhs.type;
  }
  if (!(lhs.timeUsec == rhs.timeUsec)) {
    return lhs.timeUsec < rhs.timeUsec;
  }
  if (!(lhs.timeMsec == rhs.timeMsec)) {
    return lhs.timeMsec < rhs.timeMsec;
  }
  if (!(lhs.actorID == rhs.actorID)) {
    return lhs.actorID < rhs.actorID;
  }
  return false;
}


void swap(Action& a, Action& b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.timeUsec, b.timeUsec);
  swap(a.timeMsec, b.timeMsec);
  swap(a.actorID, b.actorID);
  swap(a.__isset, b.__isset);
}

template void Action::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t Action::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t Action::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t Action::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void Action::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t Action::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t Action::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t Action::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

} // ranking
namespace ranking {

RankingObject::RankingObject() :
      objectID(0),
      objectType( ::ranking::RankingObjectType::OBJ_TYPE_A),
      actorID(0),
      createTime(0),
      weight(0) {}


RankingObject::~RankingObject() {}

RankingObject::RankingObject(apache::thrift::FragileConstructor, int64_t objectID__arg,  ::ranking::RankingObjectType objectType__arg, int64_t actorID__arg, int64_t createTime__arg,  ::ranking::RankingPayloadIntMap payloadIntMap__arg,  ::ranking::RankingPayloadStringMap payloadStrMap__arg,  ::ranking::RankingPayloadVecMap payloadVecMap__arg, ::std::vector< ::ranking::Action> actions__arg, double weight__arg) :
    objectID(std::move(objectID__arg)),
    objectType(std::move(objectType__arg)),
    actorID(std::move(actorID__arg)),
    createTime(std::move(createTime__arg)),
    payloadIntMap(std::move(payloadIntMap__arg)),
    payloadStrMap(std::move(payloadStrMap__arg)),
    payloadVecMap(std::move(payloadVecMap__arg)),
    actions(std::move(actions__arg)),
    weight(std::move(weight__arg)) {
  __isset.objectID = true;
  __isset.objectType = true;
  __isset.actorID = true;
  __isset.createTime = true;
  __isset.payloadIntMap = true;
  __isset.payloadStrMap = true;
  __isset.payloadVecMap = true;
  __isset.actions = true;
  __isset.weight = true;
}

void RankingObject::__clear() {
  // clear all fields
  objectID = 0;
  objectType =  ::ranking::RankingObjectType::OBJ_TYPE_A;
  actorID = 0;
  createTime = 0;
  payloadIntMap.clear();
  payloadStrMap.clear();
  payloadVecMap.clear();
  actions.clear();
  weight = 0;
  __isset = {};
}

bool RankingObject::operator==(const RankingObject& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.objectID == rhs.objectID)) {
    return false;
  }
  if (!(lhs.objectType == rhs.objectType)) {
    return false;
  }
  if (!(lhs.actorID == rhs.actorID)) {
    return false;
  }
  if (!(lhs.createTime == rhs.createTime)) {
    return false;
  }
  if (!(lhs.payloadIntMap == rhs.payloadIntMap)) {
    return false;
  }
  if (!(lhs.payloadStrMap == rhs.payloadStrMap)) {
    return false;
  }
  if (!(lhs.payloadVecMap == rhs.payloadVecMap)) {
    return false;
  }
  if (!(lhs.actions == rhs.actions)) {
    return false;
  }
  if (!(lhs.weight == rhs.weight)) {
    return false;
  }
  return true;
}

const  ::ranking::RankingPayloadIntMap& RankingObject::get_payloadIntMap() const& {
  return payloadIntMap;
}

 ::ranking::RankingPayloadIntMap RankingObject::get_payloadIntMap() && {
  return std::move(payloadIntMap);
}

const  ::ranking::RankingPayloadStringMap& RankingObject::get_payloadStrMap() const& {
  return payloadStrMap;
}

 ::ranking::RankingPayloadStringMap RankingObject::get_payloadStrMap() && {
  return std::move(payloadStrMap);
}

const  ::ranking::RankingPayloadVecMap& RankingObject::get_payloadVecMap() const& {
  return payloadVecMap;
}

 ::ranking::RankingPayloadVecMap RankingObject::get_payloadVecMap() && {
  return std::move(payloadVecMap);
}

const ::std::vector< ::ranking::Action>& RankingObject::get_actions() const& {
  return actions;
}

::std::vector< ::ranking::Action> RankingObject::get_actions() && {
  return std::move(actions);
}


void swap(RankingObject& a, RankingObject& b) {
  using ::std::swap;
  swap(a.objectID, b.objectID);
  swap(a.objectType, b.objectType);
  swap(a.actorID, b.actorID);
  swap(a.createTime, b.createTime);
  swap(a.payloadIntMap, b.payloadIntMap);
  swap(a.payloadStrMap, b.payloadStrMap);
  swap(a.payloadVecMap, b.payloadVecMap);
  swap(a.actions, b.actions);
  swap(a.weight, b.weight);
  swap(a.__isset, b.__isset);
}

template void RankingObject::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t RankingObject::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t RankingObject::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t RankingObject::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void RankingObject::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t RankingObject::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t RankingObject::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t RankingObject::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

} // ranking
namespace ranking {

RankingStory::RankingStory(apache::thrift::FragileConstructor, int64_t storyID__arg, ::std::vector< ::ranking::RankingObject> objects__arg, double weight__arg,  ::ranking::RankingStoryType storyType__arg) :
    storyID(std::move(storyID__arg)),
    objects(std::move(objects__arg)),
    weight(std::move(weight__arg)),
    storyType(std::move(storyType__arg)) {
  __isset.storyID = true;
  __isset.objects = true;
  __isset.weight = true;
  __isset.storyType = true;
}

void RankingStory::__clear() {
  // clear all fields
  storyID = 0;
  objects.clear();
  weight = 0;
  storyType =  ::ranking::RankingStoryType::STORY_TYPE_A;
  __isset = {};
}

bool RankingStory::operator==(const RankingStory& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.storyID == rhs.storyID)) {
    return false;
  }
  if (!(lhs.objects == rhs.objects)) {
    return false;
  }
  if (!(lhs.weight == rhs.weight)) {
    return false;
  }
  if (!(lhs.storyType == rhs.storyType)) {
    return false;
  }
  return true;
}

const ::std::vector< ::ranking::RankingObject>& RankingStory::get_objects() const& {
  return objects;
}

::std::vector< ::ranking::RankingObject> RankingStory::get_objects() && {
  return std::move(objects);
}


void swap(RankingStory& a, RankingStory& b) {
  using ::std::swap;
  swap(a.storyID, b.storyID);
  swap(a.objects, b.objects);
  swap(a.weight, b.weight);
  swap(a.storyType, b.storyType);
  swap(a.__isset, b.__isset);
}

template void RankingStory::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t RankingStory::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t RankingStory::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t RankingStory::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void RankingStory::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t RankingStory::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t RankingStory::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t RankingStory::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

} // ranking
namespace ranking {

RankingResponse::RankingResponse(apache::thrift::FragileConstructor, int64_t queryID__arg, ::std::vector< ::ranking::RankingStory> rankingStories__arg, ::std::vector<int32_t> objectCounts__arg, ::std::string metadata__arg) :
    queryID(std::move(queryID__arg)),
    rankingStories(std::move(rankingStories__arg)),
    objectCounts(std::move(objectCounts__arg)),
    metadata(std::move(metadata__arg)) {
  __isset.queryID = true;
  __isset.rankingStories = true;
  __isset.objectCounts = true;
  __isset.metadata = true;
}

void RankingResponse::__clear() {
  // clear all fields
  queryID = 0;
  rankingStories.clear();
  objectCounts.clear();
  metadata = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  __isset = {};
}

bool RankingResponse::operator==(const RankingResponse& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.queryID == rhs.queryID)) {
    return false;
  }
  if (!(lhs.rankingStories == rhs.rankingStories)) {
    return false;
  }
  if (!(lhs.objectCounts == rhs.objectCounts)) {
    return false;
  }
  if (!(lhs.metadata == rhs.metadata)) {
    return false;
  }
  return true;
}

const ::std::vector< ::ranking::RankingStory>& RankingResponse::get_rankingStories() const& {
  return rankingStories;
}

::std::vector< ::ranking::RankingStory> RankingResponse::get_rankingStories() && {
  return std::move(rankingStories);
}

const ::std::vector<int32_t>& RankingResponse::get_objectCounts() const& {
  return objectCounts;
}

::std::vector<int32_t> RankingResponse::get_objectCounts() && {
  return std::move(objectCounts);
}


void swap(RankingResponse& a, RankingResponse& b) {
  using ::std::swap;
  swap(a.queryID, b.queryID);
  swap(a.rankingStories, b.rankingStories);
  swap(a.objectCounts, b.objectCounts);
  swap(a.metadata, b.metadata);
  swap(a.__isset, b.__isset);
}

template void RankingResponse::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t RankingResponse::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t RankingResponse::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t RankingResponse::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void RankingResponse::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t RankingResponse::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t RankingResponse::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t RankingResponse::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

} // ranking
