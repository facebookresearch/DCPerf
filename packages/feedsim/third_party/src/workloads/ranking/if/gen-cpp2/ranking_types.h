/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#pragma once

#include <thrift/lib/cpp2/gen/module_types_h.h>


#include "folly/small_vector.h"
#include "folly/container/F14Map.h"

namespace apache {
namespace thrift {
namespace tag {
struct message;
struct type;
struct timeUsec;
struct timeMsec;
struct actorID;
struct objectID;
struct objectType;
struct actorID;
struct createTime;
struct payloadIntMap;
struct payloadStrMap;
struct payloadVecMap;
struct actions;
struct weight;
struct storyID;
struct objects;
struct weight;
struct storyType;
struct queryID;
struct rankingStories;
struct objectCounts;
struct metadata;
} // namespace tag
namespace detail {
#ifndef APACHE_THRIFT_ACCESSOR_message
#define APACHE_THRIFT_ACCESSOR_message
APACHE_THRIFT_DEFINE_ACCESSOR(message);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_type
#define APACHE_THRIFT_ACCESSOR_type
APACHE_THRIFT_DEFINE_ACCESSOR(type);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_timeUsec
#define APACHE_THRIFT_ACCESSOR_timeUsec
APACHE_THRIFT_DEFINE_ACCESSOR(timeUsec);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_timeMsec
#define APACHE_THRIFT_ACCESSOR_timeMsec
APACHE_THRIFT_DEFINE_ACCESSOR(timeMsec);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_actorID
#define APACHE_THRIFT_ACCESSOR_actorID
APACHE_THRIFT_DEFINE_ACCESSOR(actorID);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_objectID
#define APACHE_THRIFT_ACCESSOR_objectID
APACHE_THRIFT_DEFINE_ACCESSOR(objectID);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_objectType
#define APACHE_THRIFT_ACCESSOR_objectType
APACHE_THRIFT_DEFINE_ACCESSOR(objectType);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_actorID
#define APACHE_THRIFT_ACCESSOR_actorID
APACHE_THRIFT_DEFINE_ACCESSOR(actorID);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_createTime
#define APACHE_THRIFT_ACCESSOR_createTime
APACHE_THRIFT_DEFINE_ACCESSOR(createTime);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_payloadIntMap
#define APACHE_THRIFT_ACCESSOR_payloadIntMap
APACHE_THRIFT_DEFINE_ACCESSOR(payloadIntMap);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_payloadStrMap
#define APACHE_THRIFT_ACCESSOR_payloadStrMap
APACHE_THRIFT_DEFINE_ACCESSOR(payloadStrMap);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_payloadVecMap
#define APACHE_THRIFT_ACCESSOR_payloadVecMap
APACHE_THRIFT_DEFINE_ACCESSOR(payloadVecMap);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_actions
#define APACHE_THRIFT_ACCESSOR_actions
APACHE_THRIFT_DEFINE_ACCESSOR(actions);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_weight
#define APACHE_THRIFT_ACCESSOR_weight
APACHE_THRIFT_DEFINE_ACCESSOR(weight);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_storyID
#define APACHE_THRIFT_ACCESSOR_storyID
APACHE_THRIFT_DEFINE_ACCESSOR(storyID);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_objects
#define APACHE_THRIFT_ACCESSOR_objects
APACHE_THRIFT_DEFINE_ACCESSOR(objects);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_weight
#define APACHE_THRIFT_ACCESSOR_weight
APACHE_THRIFT_DEFINE_ACCESSOR(weight);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_storyType
#define APACHE_THRIFT_ACCESSOR_storyType
APACHE_THRIFT_DEFINE_ACCESSOR(storyType);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_queryID
#define APACHE_THRIFT_ACCESSOR_queryID
APACHE_THRIFT_DEFINE_ACCESSOR(queryID);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_rankingStories
#define APACHE_THRIFT_ACCESSOR_rankingStories
APACHE_THRIFT_DEFINE_ACCESSOR(rankingStories);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_objectCounts
#define APACHE_THRIFT_ACCESSOR_objectCounts
APACHE_THRIFT_DEFINE_ACCESSOR(objectCounts);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_metadata
#define APACHE_THRIFT_ACCESSOR_metadata
APACHE_THRIFT_DEFINE_ACCESSOR(metadata);
#endif
} // namespace detail
} // namespace thrift
} // namespace apache

// BEGIN declare_enums
namespace ranking {

enum class RankingStoryType {
  STORY_TYPE_A = 0,
  STORY_TYPE_B = 1,
  STORY_TYPE_C = 2,
  STORY_TYPE_D = 3,
  STORY_TYPE_E = 4,
  STORY_TYPE_F = 5,
  STORY_TYPE_G = 6,
  STORY_TYPE_H = 7,
  STORY_TYPE_I = 8,
  STORY_TYPE_J = 9,
  STORY_TYPE_K = 10,
  STORY_TYPE_L = 11,
  STORY_TYPE_M = 12,
  STORY_TYPE_N = 13,
  STORY_TYPE_O = 14,
  STORY_TYPE_P = 15,
  STORY_TYPE_Q = 16,
  STORY_TYPE_R = 17,
  STORY_TYPE_S = 18,
  STORY_TYPE_T = 19,
  STORY_TYPE_U = 20,
  STORY_TYPE_V = 21,
  STORY_TYPE_W = 22,
  STORY_TYPE_X = 23,
  STORY_TYPE_Y = 24,
  STORY_TYPE_Z = 25
};




enum class RankingObjectType {
  OBJ_TYPE_A = 0,
  OBJ_TYPE_B = 1,
  OBJ_TYPE_C = 2,
  OBJ_TYPE_D = 3,
  OBJ_TYPE_E = 4,
  OBJ_TYPE_F = 5,
  OBJ_TYPE_G = 6,
  OBJ_TYPE_H = 7,
  OBJ_TYPE_I = 8,
  OBJ_TYPE_J = 9,
  OBJ_TYPE_K = 10,
  OBJ_TYPE_L = 11,
  OBJ_TYPE_M = 12,
  OBJ_TYPE_N = 13,
  OBJ_TYPE_O = 14,
  OBJ_TYPE_P = 15,
  OBJ_TYPE_Q = 16,
  OBJ_TYPE_R = 17,
  OBJ_TYPE_S = 18,
  OBJ_TYPE_T = 19,
  OBJ_TYPE_U = 20,
  OBJ_TYPE_V = 21,
  OBJ_TYPE_W = 22,
  OBJ_TYPE_X = 23,
  OBJ_TYPE_Y = 24,
  OBJ_TYPE_Z = 25
};




} // ranking
namespace std {


template<> struct hash<typename ::ranking::RankingStoryType> : public apache::thrift::detail::enum_hash<typename ::ranking::RankingStoryType> {};
template<> struct equal_to<typename ::ranking::RankingStoryType> : public apache::thrift::detail::enum_equal_to<typename ::ranking::RankingStoryType> {};


template<> struct hash<typename ::ranking::RankingObjectType> : public apache::thrift::detail::enum_hash<typename ::ranking::RankingObjectType> {};
template<> struct equal_to<typename ::ranking::RankingObjectType> : public apache::thrift::detail::enum_equal_to<typename ::ranking::RankingObjectType> {};


} // std

namespace apache { namespace thrift {


template <> struct TEnumDataStorage<::ranking::RankingStoryType>;

template <> struct TEnumTraits<::ranking::RankingStoryType> {
  using type = ::ranking::RankingStoryType;

  static constexpr std::size_t const size = 26;
  static folly::Range<type const*> const values;
  static folly::Range<folly::StringPiece const*> const names;

  static char const* findName(type value);
  static bool findValue(char const* name, type* out);

  static constexpr type min() { return type::STORY_TYPE_A; }
  static constexpr type max() { return type::STORY_TYPE_Z; }
};


template <> struct TEnumDataStorage<::ranking::RankingObjectType>;

template <> struct TEnumTraits<::ranking::RankingObjectType> {
  using type = ::ranking::RankingObjectType;

  static constexpr std::size_t const size = 26;
  static folly::Range<type const*> const values;
  static folly::Range<folly::StringPiece const*> const names;

  static char const* findName(type value);
  static bool findValue(char const* name, type* out);

  static constexpr type min() { return type::OBJ_TYPE_A; }
  static constexpr type max() { return type::OBJ_TYPE_Z; }
};


}} // apache::thrift

namespace ranking {

using _RankingStoryType_EnumMapFactory = apache::thrift::detail::TEnumMapFactory<RankingStoryType>;
extern const _RankingStoryType_EnumMapFactory::ValuesToNamesMapType _RankingStoryType_VALUES_TO_NAMES;
extern const _RankingStoryType_EnumMapFactory::NamesToValuesMapType _RankingStoryType_NAMES_TO_VALUES;

using _RankingObjectType_EnumMapFactory = apache::thrift::detail::TEnumMapFactory<RankingObjectType>;
extern const _RankingObjectType_EnumMapFactory::ValuesToNamesMapType _RankingObjectType_VALUES_TO_NAMES;
extern const _RankingObjectType_EnumMapFactory::NamesToValuesMapType _RankingObjectType_NAMES_TO_VALUES;

} // ranking

// END declare_enums
// BEGIN struct_indirection

// END struct_indirection
// BEGIN forward_declare
namespace ranking {
class Payload;
class Action;
class RankingObject;
class RankingStory;
class RankingResponse;
} // ranking
// END forward_declare
// BEGIN typedefs
namespace ranking {
typedef folly::small_vector<int64_t, 8> SmallListI64;
typedef folly::F14FastMap<int16_t, int64_t> RankingPayloadIntMap;
typedef folly::F14FastMap<int16_t, ::std::string> RankingPayloadStringMap;
typedef folly::F14FastMap<int16_t,  ::ranking::SmallListI64> RankingPayloadVecMap;

} // ranking
// END typedefs
// BEGIN hash_and_equal_to
// END hash_and_equal_to
namespace ranking {
class Payload final : private apache::thrift::detail::st::ComparisonOperators<Payload> {
 public:

  Payload() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  Payload(apache::thrift::FragileConstructor, ::std::string message__arg);

  Payload(Payload&&) = default;

  Payload(const Payload&) = default;

  Payload& operator=(Payload&&) = default;

  Payload& operator=(const Payload&) = default;
  void __clear();
 public:
  ::std::string message;

 public:
  struct __isset {
    bool message;
  } __isset = {};
  bool operator==(const Payload& rhs) const;
  bool operator<(const Payload& rhs) const;

  const ::std::string& get_message() const& {
    return message;
  }

  ::std::string get_message() && {
    return std::move(message);
  }

  template <typename T_Payload_message_struct_setter = ::std::string>
  ::std::string& set_message(T_Payload_message_struct_setter&& message_) {
    message = std::forward<T_Payload_message_struct_setter>(message_);
    __isset.message = true;
    return message;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< Payload >;
};

void swap(Payload& a, Payload& b);

template <class Protocol_>
uint32_t Payload::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

} // ranking
namespace ranking {
class Action final : private apache::thrift::detail::st::ComparisonOperators<Action> {
 public:

  Action() :
      type(0),
      timeUsec(0),
      timeMsec(0),
      actorID(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  Action(apache::thrift::FragileConstructor, int16_t type__arg, int64_t timeUsec__arg, int32_t timeMsec__arg, int64_t actorID__arg);

  Action(Action&&) = default;

  Action(const Action&) = default;

  Action& operator=(Action&&) = default;

  Action& operator=(const Action&) = default;
  void __clear();
 public:
  int16_t type;
 public:
  int64_t timeUsec;
 public:
  int32_t timeMsec;
 public:
  int64_t actorID;

 public:
  struct __isset {
    bool type;
    bool timeUsec;
    bool timeMsec;
    bool actorID;
  } __isset = {};
  bool operator==(const Action& rhs) const;
  bool operator<(const Action& rhs) const;

  int16_t get_type() const {
    return type;
  }

  int16_t& set_type(int16_t type_) {
    type = type_;
    __isset.type = true;
    return type;
  }

  int64_t get_timeUsec() const {
    return timeUsec;
  }

  int64_t& set_timeUsec(int64_t timeUsec_) {
    timeUsec = timeUsec_;
    __isset.timeUsec = true;
    return timeUsec;
  }

  int32_t get_timeMsec() const {
    return timeMsec;
  }

  int32_t& set_timeMsec(int32_t timeMsec_) {
    timeMsec = timeMsec_;
    __isset.timeMsec = true;
    return timeMsec;
  }

  int64_t get_actorID() const {
    return actorID;
  }

  int64_t& set_actorID(int64_t actorID_) {
    actorID = actorID_;
    __isset.actorID = true;
    return actorID;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< Action >;
};

void swap(Action& a, Action& b);

template <class Protocol_>
uint32_t Action::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

} // ranking
namespace ranking {
class RankingObject final : private apache::thrift::detail::st::ComparisonOperators<RankingObject> {
 public:

  RankingObject();

  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  RankingObject(apache::thrift::FragileConstructor, int64_t objectID__arg,  ::ranking::RankingObjectType objectType__arg, int64_t actorID__arg, int64_t createTime__arg,  ::ranking::RankingPayloadIntMap payloadIntMap__arg,  ::ranking::RankingPayloadStringMap payloadStrMap__arg,  ::ranking::RankingPayloadVecMap payloadVecMap__arg, ::std::vector< ::ranking::Action> actions__arg, double weight__arg);

  RankingObject(RankingObject&&) = default;

  RankingObject(const RankingObject&) = default;

  RankingObject& operator=(RankingObject&&) = default;

  RankingObject& operator=(const RankingObject&) = default;
  void __clear();

  ~RankingObject();

 public:
  int64_t objectID;
 public:
   ::ranking::RankingObjectType objectType;
 public:
  int64_t actorID;
 public:
  int64_t createTime;
 public:
   ::ranking::RankingPayloadIntMap payloadIntMap;
 public:
   ::ranking::RankingPayloadStringMap payloadStrMap;
 public:
   ::ranking::RankingPayloadVecMap payloadVecMap;
 public:
  ::std::vector< ::ranking::Action> actions;
 public:
  double weight;

 public:
  struct __isset {
    bool objectID;
    bool objectType;
    bool actorID;
    bool createTime;
    bool payloadIntMap;
    bool payloadStrMap;
    bool payloadVecMap;
    bool actions;
    bool weight;
  } __isset = {};
  bool operator==(const RankingObject& rhs) const;
  bool operator<(const RankingObject& rhs) const;

  int64_t get_objectID() const {
    return objectID;
  }

  int64_t& set_objectID(int64_t objectID_) {
    objectID = objectID_;
    __isset.objectID = true;
    return objectID;
  }

   ::ranking::RankingObjectType get_objectType() const {
    return objectType;
  }

   ::ranking::RankingObjectType& set_objectType( ::ranking::RankingObjectType objectType_) {
    objectType = objectType_;
    __isset.objectType = true;
    return objectType;
  }

  int64_t get_actorID() const {
    return actorID;
  }

  int64_t& set_actorID(int64_t actorID_) {
    actorID = actorID_;
    __isset.actorID = true;
    return actorID;
  }

  int64_t get_createTime() const {
    return createTime;
  }

  int64_t& set_createTime(int64_t createTime_) {
    createTime = createTime_;
    __isset.createTime = true;
    return createTime;
  }
  const  ::ranking::RankingPayloadIntMap& get_payloadIntMap() const&;
   ::ranking::RankingPayloadIntMap get_payloadIntMap() &&;

  template <typename T_RankingObject_payloadIntMap_struct_setter =  ::ranking::RankingPayloadIntMap>
   ::ranking::RankingPayloadIntMap& set_payloadIntMap(T_RankingObject_payloadIntMap_struct_setter&& payloadIntMap_) {
    payloadIntMap = std::forward<T_RankingObject_payloadIntMap_struct_setter>(payloadIntMap_);
    __isset.payloadIntMap = true;
    return payloadIntMap;
  }
  const  ::ranking::RankingPayloadStringMap& get_payloadStrMap() const&;
   ::ranking::RankingPayloadStringMap get_payloadStrMap() &&;

  template <typename T_RankingObject_payloadStrMap_struct_setter =  ::ranking::RankingPayloadStringMap>
   ::ranking::RankingPayloadStringMap& set_payloadStrMap(T_RankingObject_payloadStrMap_struct_setter&& payloadStrMap_) {
    payloadStrMap = std::forward<T_RankingObject_payloadStrMap_struct_setter>(payloadStrMap_);
    __isset.payloadStrMap = true;
    return payloadStrMap;
  }
  const  ::ranking::RankingPayloadVecMap& get_payloadVecMap() const&;
   ::ranking::RankingPayloadVecMap get_payloadVecMap() &&;

  template <typename T_RankingObject_payloadVecMap_struct_setter =  ::ranking::RankingPayloadVecMap>
   ::ranking::RankingPayloadVecMap& set_payloadVecMap(T_RankingObject_payloadVecMap_struct_setter&& payloadVecMap_) {
    payloadVecMap = std::forward<T_RankingObject_payloadVecMap_struct_setter>(payloadVecMap_);
    __isset.payloadVecMap = true;
    return payloadVecMap;
  }
  const ::std::vector< ::ranking::Action>& get_actions() const&;
  ::std::vector< ::ranking::Action> get_actions() &&;

  template <typename T_RankingObject_actions_struct_setter = ::std::vector< ::ranking::Action>>
  ::std::vector< ::ranking::Action>& set_actions(T_RankingObject_actions_struct_setter&& actions_) {
    actions = std::forward<T_RankingObject_actions_struct_setter>(actions_);
    __isset.actions = true;
    return actions;
  }

  double get_weight() const {
    return weight;
  }

  double& set_weight(double weight_) {
    weight = weight_;
    __isset.weight = true;
    return weight;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< RankingObject >;
};

void swap(RankingObject& a, RankingObject& b);

template <class Protocol_>
uint32_t RankingObject::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

} // ranking
namespace ranking {
class RankingStory final : private apache::thrift::detail::st::ComparisonOperators<RankingStory> {
 public:

  RankingStory() :
      storyID(0),
      weight(0),
      storyType( ::ranking::RankingStoryType::STORY_TYPE_A) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  RankingStory(apache::thrift::FragileConstructor, int64_t storyID__arg, ::std::vector< ::ranking::RankingObject> objects__arg, double weight__arg,  ::ranking::RankingStoryType storyType__arg);

  RankingStory(RankingStory&&) = default;

  RankingStory(const RankingStory&) = default;

  RankingStory& operator=(RankingStory&&) = default;

  RankingStory& operator=(const RankingStory&) = default;
  void __clear();
 public:
  int64_t storyID;
 public:
  ::std::vector< ::ranking::RankingObject> objects;
 public:
  double weight;
 public:
   ::ranking::RankingStoryType storyType;

 public:
  struct __isset {
    bool storyID;
    bool objects;
    bool weight;
    bool storyType;
  } __isset = {};
  bool operator==(const RankingStory& rhs) const;
  bool operator<(const RankingStory& rhs) const;

  int64_t get_storyID() const {
    return storyID;
  }

  int64_t& set_storyID(int64_t storyID_) {
    storyID = storyID_;
    __isset.storyID = true;
    return storyID;
  }
  const ::std::vector< ::ranking::RankingObject>& get_objects() const&;
  ::std::vector< ::ranking::RankingObject> get_objects() &&;

  template <typename T_RankingStory_objects_struct_setter = ::std::vector< ::ranking::RankingObject>>
  ::std::vector< ::ranking::RankingObject>& set_objects(T_RankingStory_objects_struct_setter&& objects_) {
    objects = std::forward<T_RankingStory_objects_struct_setter>(objects_);
    __isset.objects = true;
    return objects;
  }

  double get_weight() const {
    return weight;
  }

  double& set_weight(double weight_) {
    weight = weight_;
    __isset.weight = true;
    return weight;
  }

   ::ranking::RankingStoryType get_storyType() const {
    return storyType;
  }

   ::ranking::RankingStoryType& set_storyType( ::ranking::RankingStoryType storyType_) {
    storyType = storyType_;
    __isset.storyType = true;
    return storyType;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< RankingStory >;
};

void swap(RankingStory& a, RankingStory& b);

template <class Protocol_>
uint32_t RankingStory::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

} // ranking
namespace ranking {
class RankingResponse final : private apache::thrift::detail::st::ComparisonOperators<RankingResponse> {
 public:

  RankingResponse() :
      queryID(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  RankingResponse(apache::thrift::FragileConstructor, int64_t queryID__arg, ::std::vector< ::ranking::RankingStory> rankingStories__arg, ::std::vector<int32_t> objectCounts__arg, ::std::string metadata__arg);

  RankingResponse(RankingResponse&&) = default;

  RankingResponse(const RankingResponse&) = default;

  RankingResponse& operator=(RankingResponse&&) = default;

  RankingResponse& operator=(const RankingResponse&) = default;
  void __clear();
 public:
  int64_t queryID;
 public:
  ::std::vector< ::ranking::RankingStory> rankingStories;
 public:
  ::std::vector<int32_t> objectCounts;
 public:
  ::std::string metadata;

 public:
  struct __isset {
    bool queryID;
    bool rankingStories;
    bool objectCounts;
    bool metadata;
  } __isset = {};
  bool operator==(const RankingResponse& rhs) const;
  bool operator<(const RankingResponse& rhs) const;

  int64_t get_queryID() const {
    return queryID;
  }

  int64_t& set_queryID(int64_t queryID_) {
    queryID = queryID_;
    __isset.queryID = true;
    return queryID;
  }
  const ::std::vector< ::ranking::RankingStory>& get_rankingStories() const&;
  ::std::vector< ::ranking::RankingStory> get_rankingStories() &&;

  template <typename T_RankingResponse_rankingStories_struct_setter = ::std::vector< ::ranking::RankingStory>>
  ::std::vector< ::ranking::RankingStory>& set_rankingStories(T_RankingResponse_rankingStories_struct_setter&& rankingStories_) {
    rankingStories = std::forward<T_RankingResponse_rankingStories_struct_setter>(rankingStories_);
    __isset.rankingStories = true;
    return rankingStories;
  }
  const ::std::vector<int32_t>& get_objectCounts() const&;
  ::std::vector<int32_t> get_objectCounts() &&;

  template <typename T_RankingResponse_objectCounts_struct_setter = ::std::vector<int32_t>>
  ::std::vector<int32_t>& set_objectCounts(T_RankingResponse_objectCounts_struct_setter&& objectCounts_) {
    objectCounts = std::forward<T_RankingResponse_objectCounts_struct_setter>(objectCounts_);
    __isset.objectCounts = true;
    return objectCounts;
  }

  const ::std::string& get_metadata() const& {
    return metadata;
  }

  ::std::string get_metadata() && {
    return std::move(metadata);
  }

  template <typename T_RankingResponse_metadata_struct_setter = ::std::string>
  ::std::string& set_metadata(T_RankingResponse_metadata_struct_setter&& metadata_) {
    metadata = std::forward<T_RankingResponse_metadata_struct_setter>(metadata_);
    __isset.metadata = true;
    return metadata;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< RankingResponse >;
};

void swap(RankingResponse& a, RankingResponse& b);

template <class Protocol_>
uint32_t RankingResponse::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

} // ranking
